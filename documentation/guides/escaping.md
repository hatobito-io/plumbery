# Errors, escaping and halting
<!-- vim: set tw=80 : -->

As a request is moving through a pipeline, some steps may produce errors. In
that case the pipeline stops and returns the first error encountered, without
calling the rest of the pipes.

This is not always the desired behavior. Let's consider a pipeline where the
first few pipes validate different aspects of the request.

!elixir examples/recovery_1.exs

When calling the pipeline, we want it to report validation errors for all
aspects, not just the one it happens to check first. That is where the concept
of *escaping* comes into play. By default a pipeline escapes on error, meaning
that as soon as the request has an error, the pipeline returns immediately
without calling any further steps. After escaping is turned off, all subsequent
pipes will be called regardless of wheter the request has errors or not. That
provides an opportunity for counter-acting an error or adding another error that
is orthogonal to the ones generated by previous steps.

Let's modify the example so it actually does what we want.

!elixir examples/recovery_2.exs

So how does `escape_on_error` options work? That's pretty simple. If it is
`true` (the default value) then as soon as there is an error in the request, the
pipeline returns immediately. When that option is `false`, all subsequent pipes
will be called.

Plumbery provides one more way of controlling the pipeline â€“ pipeline halting.
Any pipe can call `Plumbery.Request.halt/1`. That causes the pipeline to return
immeditely and unconditionally.


!elixir examples/recovery_3.exs

